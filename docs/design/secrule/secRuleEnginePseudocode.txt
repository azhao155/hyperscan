func init()
    rules = parseRules()

    // @rx, @beginsWith, @contains, @containsWord, @eq, @pm, @pmf, @pmFromFile are all rolled into the same regex engine
    // multiMatch transformations are unrolled into separate transformation pipelines
    scanPatterns = initScanPatterns(rules)
    // shape of scanPatterns is something like
    // [
    //     "ARGS": [
    //         // scan target object:
    //         {
    //             transformations: [ "urlDecodeUni", "htmlEntityDecode", "lowercase" ],
    //             patterns: [
    //                 { patternId: 1, regex: "(?i:(sleep\((\s*?)(\d*?)(\s*?)\)))" },
    //                 { patternId: 2, regex: "(?i:(?:(union(.*?)select(.*?)from)))" },
    //                 ...
    //             ],
    //             exceptTargets: [ "ARGS:someArgument", "ARGS:someOtherArgument" ]
    //             scanEngine: { ... } // a HyperScan instance or RE2 set instance
    //          },
    //          {
    //             transformations: ["urlDecodeUni", "htmlEntityDecode"], // here a different transformation pipeline than above
    //             ...
    //          }
    //     ]
    //     "ARG_NAMES: [
    //         // can point to same scan target object instances as above
    //         ...
    //     ]
    // ]



// Entry point for each request
func evalRequest(req)
    scanResults = scanRequestContent(rules, req)
    return evaluateRules(rules, scanResults)


// Single pass through the request content, ignoring rule order and chaining logic
func scanRequestContent(req)
    result = {}

    result.matches += scanTarget(req.uri)
    getargs = parseGetArgs(req.uri)
    result.argscount += len(getargs)
    for each getargs
        result.matches += scanTarget(arg)

    result.headercount = len(req.headers)
    for each req.headers
        result.matches += scanTarget(header)

    for each cookie
        result.matches += scanTarget(cookie)

    func bodyFieldCallback(field)
         += scanTarget(field)
        result.argscount += 1

    while c = req.nextBodyChunk()
        // parseBodyChunk will use a callback based parser (like SAX) so we avoid having to build an entire AST of the body in memory
        // parseBodyChunk could also optionally do decompression of compressed bodies (stretch, as ModSec doesn't do this)
        parseBodyChunk(bodyFieldCallback, c)


// Transform and scan a single target
func scanTarget(content, result)
    for each scanTarget in scanPatterns[content.targetName]
        if scanTarget.exceptTargets.contains(content.targetName)
            continue

        tf = transform(scanTarget.transformations, content)
        mm = scanEngine.scan(tf)

        // Update with info on which patterns were hit
        for each m in mm
            result.matches += (m.ruleId, content.targetName, m.position, m.value)

    if length of fieldName is used in any rule (example: "&REQUEST_HEADERS:Referer" in CRS rule 943120)
        result.lengths[content.targetName] = len(content.value)


// Sequential interpreter pass through the rules
func evalRules(rules, scanResults)
    environment = []
    for each ruleChains
        action = evalRuleChain(ruleChain, scanResults, environment)
        if action is to just log
            log()
        if action is to block
            log()
            block()


func evalRuleChain(ruleChain, scanResults, environment)
    for each rule in ruleChain
        for each target
            // Is this a target that we scanned for in the scanRequestContent phase, such as URI, ARGS, ARG_NAMES, etc.
            if isRequestContentTarget(target)
                if scanResults does not have a result for this target in this rule
                    return
            else
                // This is a target for which we need scan here in interpretation phase

                val = environment[target]
                tf = transform(rule.transformations, val)
                pattern = expandMacros(rule.pattern, environmt)
                if not scan(expandMacros, val)
                    return

    updateEnvironment(environment, rule.actions)


func updateEnvironment(environment, actions)
    expand macros in actions based on environment
    update variables such as tx.anomaly_score
    special variables such as MATCHED_VAR, MATCHED_VARS, MATCHED_VAR_NAME, MATCHED_VARS_NAMES are also updated
